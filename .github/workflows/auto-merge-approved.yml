name: Auto-merge approved PRs

on:
  # Re-evaluate when someone approves
  pull_request_review:
    types: [submitted]

  # Re-evaluate when labels change, new commits are pushed, or PR is opened/reopened
  pull_request:
    types: [opened, reopened, synchronize, labeled, unlabeled, ready_for_review]

  # Re-evaluate when a check suite completes (so we can merge right after CI turns green)
  check_suite:
    types: [completed]

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: auto-merge-${{ github.event.pull_request.number || github.event.check_suite.pull_requests[0].number || github.run_id }}
  cancel-in-progress: false

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    steps:
      - name: Auto-merge if approved and not blocked
        uses: actions/github-script@v7
        with:
          script: |
            // Determine PR number depending on trigger
            let prNumber;
            if (context.payload.pull_request?.number) {
              prNumber = context.payload.pull_request.number;
            } else if (context.payload.review?.pull_request_url) {
              prNumber = Number(context.payload.review.pull_request_url.split('/').pop());
            } else if (context.payload.check_suite?.pull_requests?.length) {
              prNumber = context.payload.check_suite.pull_requests[0].number;
            }

            if (!prNumber) {
              core.info('No PR found in event payload; exiting.');
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Fetch PR details (with small retry window). GitHub can briefly report
            // mergeable_state=unstable/unknown even when checks are green.
            const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

            let pr;
            const maxAttempts = 12;        // ~60s total
            const backoffMs = 5000;

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              const { data } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              pr = data;

              core.info(`PR #${prNumber} attempt ${attempt}/${maxAttempts}: mergeable=${pr.mergeable}, mergeable_state=${pr.mergeable_state}`);

              // If mergeability isn't computed yet, wait and retry.
              if (pr.mergeable === null || pr.mergeable_state === 'unknown') {
                await sleep(backoffMs);
                continue;
              }

              // If it's already clean, stop waiting.
              if (pr.mergeable_state === 'clean') break;

              // If checks are still running / just finished, GitHub often reports 'unstable' transiently.
              // Give it a short window to settle.
              if (['unstable'].includes(pr.mergeable_state) && attempt < maxAttempts) {
                await sleep(backoffMs);
                continue;
              }

              // For other states (dirty/blocked/behind), don't spin.
              break;
            }

            if (pr.draft) {
              core.info(`PR #${prNumber} is draft; skip.`);
              return;
            }

            const labels = (pr.labels || []).map(l => (typeof l === 'string' ? l : l.name));
            if (labels.includes('do-not-merge')) {
              core.info(`PR #${prNumber} has do-not-merge label; skip.`);
              return;
            }

            // Determine if PR is approved (latest review state per user)
            const { data: reviews } = await github.rest.pulls.listReviews({ owner, repo, pull_number: prNumber, per_page: 100 });
            const latestByUser = new Map();
            for (const r of reviews) {
              if (!r.user?.login) continue;
              latestByUser.set(r.user.login, r.state);
            }
            const approvals = [...latestByUser.values()].filter(s => s === 'APPROVED').length;
            if (approvals < 1) {
              core.info(`PR #${prNumber} approvals=${approvals}; need >=1; skip.`);
              return;
            }

            // Gate on mergeability + required checks.
            // NOTE: mergeable_state is flaky/transient (often reports `unstable` even when checks are green),
            // so we avoid using it as the primary signal.
            if (pr.mergeable !== true) {
              core.info(`Not mergeable yet (mergeable=${pr.mergeable}); skip.`);
              return;
            }

            const requiredChecks = [
              'check-author', // Check Commit Author
              'check',        // Block Forbidden Files
            ];

            const headSha = pr.head.sha;
            const { data: checkData } = await github.rest.checks.listForRef({
              owner,
              repo,
              ref: headSha,
              per_page: 100,
            });

            const checkByName = new Map((checkData.check_runs || []).map(cr => [cr.name, cr]));
            const missing = requiredChecks.filter(n => !checkByName.has(n));
            if (missing.length) {
              core.info(`Missing required checks on ${headSha}: ${missing.join(', ')}; skip.`);
              return;
            }

            const notSuccess = requiredChecks
              .map(n => checkByName.get(n))
              .filter(cr => cr.conclusion !== 'success');

            if (notSuccess.length) {
              core.info(`Required checks not SUCCESS yet: ${notSuccess.map(cr => `${cr.name}=${cr.conclusion}`).join(', ')}; skip.`);
              return;
            }

            // Merge
            try {
              await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: prNumber,
                merge_method: 'squash',
              });
              core.info(`Merged PR #${prNumber}.`);
            } catch (e) {
              core.warning(`Failed to merge PR #${prNumber}: ${e.message}`);
              throw e;
            }
